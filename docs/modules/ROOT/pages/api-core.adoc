= OpenZeppelin Upgrades Core

The `@openzeppelin/upgrades-core` package provides a command-line interface to check for upgrade safety and storage layout compatibility in upgradeable contracts.  It can be used throughout your development process to ensure that your contracts are upgrade safe and compatible with previous versions.

It also provides APIs to perform these checks programmatically, and contains the core logic for these checks to be performed with the OpenZeppelin Upgrades plugins.

[[cli]]
== Command-Line Interface

Detects upgradeable contracts from a build info directory and validates whether they are upgrade safe.

[[cli-prerequisites]]
=== Prerequisites

Before using the command-line interface, you must define upgradeable contracts so that they can be detected and validated, define reference contracts for storage layout comparisons, and compile your contracts.

==== Define Upgradeable Contracts

The command-line interface performs upgrade safety checks on contracts that look like upgradeable contracts. Specifically, it performs checks on implementation contracts that meet any of the following criteria:

- Inherits https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/proxy/utils/Initializable.sol[`Initializable`].
- Has an `upgradeTo(address)` function. This is the case for contracts that inherit https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/proxy/utils/UUPSUpgradeable.sol[`UUPSUpgradeable`].
- Has the NatSpec annotation `@custom:oz-upgrades`
- Has the NatSpec annotation `@custom:oz-upgrades-from <reference>` according to <<define-reference-contracts, Define Reference Contracts>> below.

If your implementation contract does not inherit `Initializable` or `UUPSUpgradeable`, add the NatSpec annotation `@custom:oz-upgrades` or `@custom:oz-upgrades-from <reference>` so that it can be detected as an upgradeable contract.

[[define-reference-contracts]]
==== Define Reference Contracts

IMPORTANT: If an implementation contract is meant to upgraded from a previous version, you *MUST* define a reference contract for storage layout comparisons.  Otherwise, you will not receive errors if there are any storage layout incompatibilities.

Define a reference contract by adding the NatSpec annotation `@custom:oz-upgrades-from <reference>` to your implementation contract, where `<reference>` is the contract name or fully qualified contract name of the reference contract to use for storage layout comparisons.

Example:
[source,solidity]
----
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/// @custom:oz-upgrades-from MyContractV1
contract MyContractV2 {
  ...
}
----

Or:
[source,solidity]
----
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/// @custom:oz-upgrades-from contracts/MyContract.sol:MyContractV1
contract MyContractV2 {
  ...
}
----

==== Compile Contracts

Compile your contracts and ensure that your build artifacts are available as JSON files with Solidity compiler inputs and outputs in a build info directory. The compiler output must include storage layouts. If any previous build artifacts exist, they must be cleaned first to avoid duplicate contract definitions.

===== Hardhat
[source,bash]
----
npx hardhat clean && npx hardhat compile
----

===== Foundry
[source,bash]
----
forge clean && forge build --build-info --extra-output storageLayout
----

=== Usage

After performing the prerequisites, run the `npx @openzeppelin/upgrades-core validate` command to validate your contracts:

:prewrap:
[source,bash]
----
npx @openzeppelin/upgrades-core validate [<build-info-dir>] [options]

Arguments:
  <build-info-dir>  Optional path to the build info directory which contains JSON files with Solidity compiler input and output. Defaults to the Hardhat or Foundry build-info directory if running in a Hardhat or Foundry project.

Options:
  --unsafeAllow "<validation errors>"  Comma or space separated list to selectively disable one or more validation errors. Supported values are: state-variable-assignment, state-variable-immutable, external-library-linking, struct-definition, enum-definition, constructor, delegatecall, selfdestruct, missing-public-upgradeto
  --unsafeAllowRenames  Configure storage layout check to allow variable renaming.
  --unsafeSkipStorageCheck  Skips checking for storage layout compatibility errors. This is a dangerous option meant to be used as a last resort.
----
:prewrap!:

If any errors are found, the command will exit with a non-zero exit code and print a detailed report of the errors to the console.

== High-Level API

The high-level API is a programmatic equivalent to the <<cli, command-line interface>>.

=== Prerequisites

Prerequisites are the same as for the command-line interface.

=== Usage

Import the `validateUpgradeSafety` function:

[source,ts]
----
import { validateUpgradeSafety } from '@openzeppelin/upgrades-core';
----

Then call the function to validate your contracts and get a summary report with the validation results.

==== validateUpgradeSafety
[source,ts]
----
validateUpgradeSafety(
  buildInfoDir?: string,
  reportOpts: ReportOptions = {},
  opts: ValidateUpgradeSafetyOptions = {},
): Promise<SummaryReport>
----

Detects upgradeable contracts from a build info directory and validates whether they are upgrade safe. Returns a <<summary-report, summary report>> with the results.

*Parameters:*

* `buildInfoDir` - the path to the build info directory which contains JSON files with Solidity compiler input and output. If not specified, uses the default Hardhat or Foundry build info directory if running in a Hardhat or Foundry project.
* `reportOpts` - an object with the following options:
** `suppressSummary` - whether to skip logging the summary report to the console before returning it.
* `opts` - an object with the following options as defined in xref:api-hardhat-upgrades.adoc#common-options[Common Options]:
** `unsafeAllow`
** `unsafeAllowRenames`
** `unsafeSkipStorageCheck`

*Returns:*

* a <<summary-report, summary report>>.

[[summary-report]]
==== SummaryReport
[source,ts]
----
interface SummaryReport {
  ok: boolean;
  explain(color?: boolean): string;
  numPassed: number;
  numTotal: number;
}
----

An object that represents the result of upgrade safety checks and storage layout comparisons, and contains a summary of all errors found.

**Members:**

* `ok` - `false` if any errors were found, otherwise `true`.
* `explain()` - returns a message explaining the errors in detail, if any.
* `numPassed` - number of contracts that passed upgrade safety checks.
* `numTotal` - total number of upgradeable contracts detected.

== Low-Level API

The low-level API works with https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-input-and-output-json-description[Solidity input and output JSON objects] and lets you perform upgrade safety checks and storage layout comparisons on individual contracts.

=== Prerequisites

Compile your contracts to get Solidity input and output JSON objects. The compiler output must include storage layouts.

Note that the other prerequisites from the <<cli-prerequisites, command-line interface>> are not required, because the low-level API does not detect upgradeable contracts automatically. Instead, you must create an instance of `UpgradeableContract` for each implementation contract that you want to validate, and call functions on it to get the upgrade safety and storage layout reports.

=== Usage

Import the `UpgradeableContract` class:

[source,ts]
----
import { UpgradeableContract } from '@openzeppelin/upgrades-core';
----

Then create an instance of `UpgradeableContract` for each implementation contract that you want to validate, and call `.getErrorReport()` and/or `.getStorageLayoutReport()` on it to get the upgrade safety and storage layout reports, respectively.

==== UpgradeableContract

This class represents the implementation for an upgradeable contract and gives access to error reports.

===== constructor UpgradeableContract
[source,ts]
----
constructor UpgradeableContract(
  name: string,
  solcInput: SolcInput,
  solcOutput: SolcOutput,
  opts?: {
    unsafeAllow?: ValidationError[],
    unsafeAllowRenames?: boolean,
    unsafeSkipStorageCheck?: boolean,
    kind?: 'uups' | 'transparent' | 'beacon',
  },
): UpgradeableContract
----

Creates a new instance of `UpgradeableContract`.

*Parameters:*

* `name` - the name of the implementation contract as either a fully qualified name or contract name. If multiple contracts have the same name, you must use the fully qualified name e.g., `contracts/Bar.sol:Bar`.
* `solcInput` - the Solidity input JSON object for the implementation contract.
* `solcOutput` - the Solidity output JSON object for the implementation contract.
* `opts` - an object with the following options as defined in xref:api-hardhat-upgrades.adoc#common-options[Common Options]:
** `kind`
** `unsafeAllow`
** `unsafeAllowRenames`
** `unsafeSkipStorageCheck`

TIP: In Hardhat, `solcInput` and `solcOutput` can be obtained from the Build Info file, which itself can be retrieved with `hre.artifacts.getBuildInfo`.

===== .getErrorReport
[source,ts]
----
getErrorReport(): Report
----

**Returns:**

* a report about errors pertaining to proxied contracts, e.g. the use of `selfdestruct`.

===== .getStorageUpgradeReport
[source,ts]
----
getStorageUpgradeReport(
  upgradedContract: UpgradeableContract,
  opts?: {
    unsafeAllow?: ValidationError[],
    unsafeAllowRenames?: boolean,
    unsafeSkipStorageCheck?: boolean,
    kind?: 'uups' | 'transparent' | 'beacon',
  },
): Report
----

Compares the storage layout of an upgradeable contract with that of a proposed upgrade.

*Parameters:*

* `upgradedContract` - another instance of `UpgradeableContract` representing the proposed upgrade.

* `opts` - an object with the following options as defined in xref:api-hardhat-upgrades.adoc#common-options[Common Options]:
** `kind`
** `unsafeAllow`
** `unsafeAllowRenames`
** `unsafeSkipStorageCheck`

**Returns:**

* a report about errors pertaining to proxied contracts, e.g. the use of `selfdestruct`, and storage layout conflicts.

==== Report
[source,ts]
----
interface Report {
  ok: boolean;
  explain(color?: boolean): string;
}
----

An object that represents the results of an analysis.

**Members:**

* `ok` - `false` if any errors were found, otherwise `true`.
* `explain()` - returns a message explaining the errors in detail, if any.

